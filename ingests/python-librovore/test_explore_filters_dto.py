#!/usr/bin/env python3
# vim: set filetype=python fileencoding=utf-8:
# -*- coding: utf-8 -*-

''' 
Experiment with DTO vs individual parameters for explore function.
Tests FastMCP schema generation and CLI compatibility.
'''

import json
import asyncio
from enum import Enum
from mcp.server.fastmcp import FastMCP
from pydantic import Field, BaseModel
from typing import Annotated, Optional


class MatchMode(Enum):
    ''' Enum for different matching modes. '''
    EXACT = "exact"
    REGEX = "regex"
    FUZZY = "fuzzy"


class ExploreFilters(BaseModel):
    ''' Filters for explore function - DTO approach. '''
    domain: Annotated[
        str, 
        Field(
            description="Filter by Sphinx domain (py, std, c, cpp, js, rst, math)", 
            default=""
        )
    ] = ""
    role: Annotated[
        str, 
        Field(
            description="Filter by role (function, class, method)", 
            default=""
        )
    ] = ""
    priority: Annotated[
        str, 
        Field(
            description="Filter by priority level (1, 0)", 
            default=""
        )
    ] = ""
    match_mode: Annotated[
        MatchMode, 
        Field(
            description="Term matching mode (exact, regex, fuzzy)", 
            default=MatchMode.FUZZY
        )
    ] = MatchMode.FUZZY
    fuzzy_threshold: Annotated[
        int, 
        Field(
            description="Fuzzy matching threshold (0-100, higher = stricter)", 
            default=50, 
            ge=0, 
            le=100
        )
    ] = 50


def explore_with_dto(
    source: Annotated[
        str,
        Field(description="URL or file path to documentation source")
    ],
    query: Annotated[
        str,
        Field(description="Search query for objects to explore")
    ],
    filters: Annotated[
        ExploreFilters,
        Field(description="Search and matching filters")
    ] = ExploreFilters(),
    max_objects: Annotated[
        int,
        Field(description="Maximum number of objects to process", default=5, ge=1, le=20)
    ] = 5,
    include_documentation: Annotated[
        bool,
        Field(description="Whether to extract documentation for each object", default=True)
    ] = True,
) -> dict[str, str]:
    ''' Explore function using DTO for filters. '''
    return {
        "approach": "DTO",
        "source": source,
        "query": query,
        "domain": filters.domain,
        "role": filters.role,
        "priority": filters.priority,
        "match_mode": filters.match_mode.value,
        "fuzzy_threshold": str(filters.fuzzy_threshold),
        "max_objects": str(max_objects),
        "include_documentation": str(include_documentation),
    }


def explore_with_params(
    source: Annotated[
        str,
        Field(description="URL or file path to documentation source")
    ],
    query: Annotated[
        str,
        Field(description="Search query for objects to explore")
    ],
    domain: Annotated[
        str,
        Field(description="Filter by Sphinx domain (py, std, c, cpp, js, rst, math)", default="")
    ] = "",
    role: Annotated[
        str,
        Field(description="Filter by role (function, class, method)", default="")
    ] = "",
    priority: Annotated[
        str,
        Field(description="Filter by priority level (1, 0)", default="")
    ] = "",
    match_mode: Annotated[
        MatchMode,
        Field(description="Term matching mode (exact, regex, fuzzy)", default=MatchMode.FUZZY)
    ] = MatchMode.FUZZY,
    fuzzy_threshold: Annotated[
        int,
        Field(description="Fuzzy matching threshold (0-100, higher = stricter)", default=50, ge=0, le=100)
    ] = 50,
    max_objects: Annotated[
        int,
        Field(description="Maximum number of objects to process", default=5, ge=1, le=20)
    ] = 5,
    include_documentation: Annotated[
        bool,
        Field(description="Whether to extract documentation for each object", default=True)
    ] = True,
) -> dict[str, str]:
    ''' Explore function using individual parameters. '''
    return {
        "approach": "Individual Parameters",
        "source": source,
        "query": query,
        "domain": domain,
        "role": role,
        "priority": priority,
        "match_mode": match_mode.value,
        "fuzzy_threshold": str(fuzzy_threshold),
        "max_objects": str(max_objects),
        "include_documentation": str(include_documentation),
    }


async def compare_schemas():
    ''' Compare JSON schemas generated by FastMCP for both approaches. '''
    print("=== FILTERS DTO EXPERIMENT ===\n")
    
    # Create FastMCP instance
    mcp = FastMCP("Explore Filters Test Server")
    
    # Register both functions
    mcp.tool()(explore_with_dto)
    mcp.tool()(explore_with_params)
    
    # Get the list of registered tools
    tools_list = await mcp.list_tools()
    print(f"Registered tools: {[tool.name for tool in tools_list]}\n")
    
    for tool in tools_list:
        print(f"{'='*60}")
        print(f"TOOL: {tool.name}")
        print(f"{'='*60}")
        print(f"Description: {tool.description}\n")
        
        # Print the input schema
        if hasattr(tool, 'inputSchema'):
            schema = tool.inputSchema
            print("Generated JSON Schema:")
            print(json.dumps(schema, indent=2))
            
            # Analyze schema structure
            print(f"\nSchema Analysis:")
            properties = schema.get('properties', {})
            required = schema.get('required', [])
            defs = schema.get('$defs', {})
            
            print(f"Required parameters: {required}")
            print(f"Total parameters: {len(properties)}")
            print(f"Definitions: {list(defs.keys())}")
            
            print(f"\nParameter Details:")
            for param_name, param_schema in properties.items():
                is_required = param_name in required
                param_type = param_schema.get('type', 'unknown')
                param_ref = param_schema.get('$ref', None)
                default_val = param_schema.get('default', 'no default')
                description = param_schema.get('description', 'no description')
                
                type_info = param_ref if param_ref else param_type
                print(f"  {param_name}:")
                print(f"    type: {type_info}")
                print(f"    required: {is_required}")
                print(f"    default: {default_val}")
                print(f"    description: {description}")
                
                # If it's a nested object, show its structure
                if param_ref and param_ref.startswith('#/$defs/'):
                    def_name = param_ref.split('/')[-1]
                    nested_def = defs.get(def_name, {})
                    if 'properties' in nested_def:
                        print(f"    nested properties: {list(nested_def['properties'].keys())}")
        
        print(f"\n")


async def test_tool_calls():
    ''' Test calling both tools with various parameter combinations. '''
    print(f"{'='*60}")
    print("TESTING TOOL CALLS")
    print(f"{'='*60}")
    
    mcp = FastMCP("Explore Filters Test Server")
    mcp.tool()(explore_with_dto)
    mcp.tool()(explore_with_params)
    
    # Test cases
    test_cases = [
        {
            "name": "Basic call - defaults",
            "params": {
                "source": "https://example.com/docs",
                "query": "Result"
            }
        },
        {
            "name": "With filters - DTO approach",
            "tool": "explore_with_dto",
            "params": {
                "source": "https://example.com/docs",
                "query": "Result",
                "filters": {
                    "domain": "py",
                    "match_mode": "fuzzy",
                    "fuzzy_threshold": 80
                },
                "max_objects": 3
            }
        },
        {
            "name": "With filters - Individual params",
            "tool": "explore_with_params", 
            "params": {
                "source": "https://example.com/docs",
                "query": "Result",
                "domain": "py",
                "match_mode": "fuzzy",
                "fuzzy_threshold": 80,
                "max_objects": 3
            }
        },
        {
            "name": "All filters - DTO",
            "tool": "explore_with_dto",
            "params": {
                "source": "https://example.com/docs",
                "query": "Error",
                "filters": {
                    "domain": "py",
                    "role": "class",
                    "priority": "1",
                    "match_mode": "exact",
                    "fuzzy_threshold": 90
                },
                "max_objects": 10,
                "include_documentation": False
            }
        }
    ]
    
    for test_case in test_cases:
        tool_name = test_case.get("tool", "explore_with_dto")
        print(f"\nTest: {test_case['name']}")
        print(f"Tool: {tool_name}")
        print(f"Params: {json.dumps(test_case['params'], indent=2)}")
        
        try:
            result = await mcp.call_tool(tool_name, test_case['params'])
            print(f"✓ SUCCESS: {result}")
        except Exception as e:
            print(f"✗ ERROR: {e}")


def test_tyro_compatibility():
    ''' Test how Tyro handles the DTO structure for CLI generation. '''
    print(f"{'='*60}")
    print("TESTING TYRO CLI COMPATIBILITY")
    print(f"{'='*60}")
    
    try:
        import tyro
        
        # Test DTO-based function with Tyro
        print("\nTesting DTO approach with Tyro:")
        print("Command would be something like:")
        print("python script.py --source https://example.com --query Result --filters.domain py --filters.match-mode fuzzy")
        
        # Test individual parameters with Tyro
        print("\nTesting individual parameters with Tyro:")
        print("Command would be something like:")
        print("python script.py --source https://example.com --query Result --domain py --match-mode fuzzy")
        
        # We could actually generate the CLI here, but it would require more setup
        print("\nNote: Full Tyro testing would require setting up actual CLI entry points")
        
    except ImportError:
        print("Tyro not available for testing - install with 'pip install tyro'")


async def main():
    ''' Run all experiments. '''
    await compare_schemas()
    await test_tool_calls()
    test_tyro_compatibility()
    
    print(f"\n{'='*60}")
    print("EXPERIMENT SUMMARY")
    print(f"{'='*60}")
    
    print("\nDTO Approach:")
    print("✓ Reduces parameter count (5 vs 9)")
    print("✓ Logical grouping of related parameters")
    print("? Creates nested JSON Schema structure")
    print("? May affect CLI UX (--filters.domain vs --domain)")
    
    print("\nIndividual Parameters:")
    print("✓ Flat parameter structure")
    print("✓ Direct CLI mapping (--domain, --role, etc.)")
    print("? Higher parameter count")
    print("? Less logical grouping")
    
    print("\nRecommendation: Review generated schemas and consider user workflows")


if __name__ == "__main__":
    asyncio.run(main())